
// This does mean that I'll have to adapt this for other microcontrollers,
// but maybe that won't be too difficult since a lot of them will be
// similar across stm32 (perhaps with reduced features).

// The thing to watch out for will be cases like e.g. a missing BRR
// register on STM32F4 devices that is present on STM32F0.

// On the other hand, if I do end up using C++ I can write a version
// that uses nice C++ namespaces and other features.
// Since the microcontroller's won't change (existing ones, anyway),
// I don't have to worry about keeping this up to date with a changing API.

#pragma once

#include <stdint.h>


// Taken from ST's header file. Presumably this is from the manual as well.

#define __CM4_REV                 0x0001U  /*!< Core revision r0p1                            */
#define __MPU_PRESENT             1U       /*!< STM32F4XX provides an MPU                     */
#define __NVIC_PRIO_BITS          4U       /*!< STM32F4XX uses 4 Bits for the Priority Levels */
#define __Vendor_SysTickConfig    0U       /*!< Set to 1 if different SysTick Config is used  */
#define __FPU_PRESENT             1U       /*!< FPU present                                   */


// // TODO: Consider auto-generating vector.s and some header file
// // containing IRQ numbers for NVIC:

// I think this has to come before the core_cmX.h include
typedef enum
{
    SysTick_IRQn = -1,
    TIM2_IRQn = 28,
    TIM3_IRQn = 29,
    TIM4_IRQn = 30,
} IRQn_Type;


#include <core_cm4.h>
#include <cmsis_compiler.h>


// In reality, I'm not sure there's real benefit to marking individual
// members as volatile. The entire struct can be marked volatile.

// TODO: Cortex-M header info, possibly auto-generated by Python via SVD
// Should probably be split into separate file

// Also naming things "Rcc_t" is *potentially* dangerous, but not if they're
// in a namespace.

// I hate the "_TypeDef" suffix but will keep it for now.



// TODO: Add the rest of the peripheral structs. I'm just adding
// the bare essentials at the moment, so everything else will have
// to come later.


// It may take a while to get through these, but it's probably
// a good learning experience to get familiar with the different
// kinds of peripherals and their registers' names and functions.



// TODO: After creating the struct, go back and add comments explaining
// what each field does.




// See section 2.3 (Table 1) for addresses of each hardware register






// See section 7 of the manual

// struct RCC_t
typedef struct
{
    uint32_t CR;
    uint32_t PLLCFGR;
    uint32_t CFGR;
    uint32_t CIR;
    uint32_t AHB1RSTR;
    uint32_t AHB2RSTR;
    uint32_t AHB3RSTR;
    uint32_t _reserved0[1];
    uint32_t APB1RSTR;
    uint32_t APB2RSTR;
    uint32_t _reserved1[2];
    uint32_t AHB1ENR;
    uint32_t AHB2ENR;
    uint32_t AHB3ENR;
    uint32_t _reserved2[1];
    uint32_t APB1ENR;
    uint32_t APB2ENR;
    uint32_t _reserved3[2];
    uint32_t AHB1LPENR;
    uint32_t AHB2LPENR;
    uint32_t AHB3LPENR;
    uint32_t _reserved4[1];
    uint32_t APB1LPENR;
    uint32_t APB2LPENR;
    uint32_t _reserved5[2];
    uint32_t BDCR;
    uint32_t CSR;
    uint32_t _reserved6[2];
    uint32_t SSCGR;
    uint32_t PLLI2SCFGR;        // RCC PLLI2S configuration register
} RCC_TypeDef;

// Is defining these too much trouble?
const uint32_t RCC_CR_HSEON =   (1 << 16);
const uint32_t RCC_CR_HSERDY =  (1 << 17);



// ...
// (reserved)
const uint32_t RCC_AHB1ENR_BKPSRAMEN =  (1 << 18);
// (reserved)
const uint32_t RCC_AHB1ENR_CRCEN =  (1 << 12);
// (reserved)
const uint32_t RCC_AHB1ENR_GPIOIEN =  (1 << 8);
const uint32_t RCC_AHB1ENR_GPIOHEN =  (1 << 7);
const uint32_t RCC_AHB1ENR_GPIOGEN =  (1 << 6);
const uint32_t RCC_AHB1ENR_GPIOFEN =  (1 << 5);
const uint32_t RCC_AHB1ENR_GPIOEEN =  (1 << 4);
const uint32_t RCC_AHB1ENR_GPIODEN =  (1 << 3);
const uint32_t RCC_AHB1ENR_GPIOCEN =  (1 << 2);
const uint32_t RCC_AHB1ENR_GPIOBEN =  (1 << 1);
const uint32_t RCC_AHB1ENR_GPIOAEN =  (1 << 0);



// Bit 31-30 reserved
constexpr uint32_t RCC_APB1ENR_DACEN = (1 << 29);
constexpr uint32_t RCC_APB1ENR_PWREN = (1 << 28);
// Bit 27 reserved
constexpr uint32_t RCC_APB1ENR_CAN2EN = (1 << 26);
constexpr uint32_t RCC_APB1ENR_CAN1EN = (1 << 25);
// Bit 24 reserved
constexpr uint32_t RCC_APB1ENR_I2C3EN = (1 << 23);
constexpr uint32_t RCC_APB1ENR_I2C2EN = (1 << 22);
constexpr uint32_t RCC_APB1ENR_I2C1EN = (1 << 21);
constexpr uint32_t RCC_APB1ENR_UART5EN = (1 << 20);
constexpr uint32_t RCC_APB1ENR_UART4EN = (1 << 19);
constexpr uint32_t RCC_APB1ENR_USART3EN = (1 << 18);
constexpr uint32_t RCC_APB1ENR_USART2EN = (1 << 17);
// Bit 16 reserved
constexpr uint32_t RCC_APB1ENR_SPI3EN = (1 << 15);
constexpr uint32_t RCC_APB1ENR_SPI2EN = (1 << 14);
// Bits 13-12 reserved
constexpr uint32_t RCC_APB1ENR_WWDGEN = (1 << 11);
// Bits 10-9 reserved
constexpr uint32_t RCC_APB1ENR_TIM14EN =  (1 << 8);
constexpr uint32_t RCC_APB1ENR_TIM13EN =  (1 << 7);
constexpr uint32_t RCC_APB1ENR_TIM12EN =  (1 << 6);
constexpr uint32_t RCC_APB1ENR_TIM7EN =  (1 << 5);
constexpr uint32_t RCC_APB1ENR_TIM6EN =  (1 << 4);
constexpr uint32_t RCC_APB1ENR_TIM5EN =  (1 << 3);
constexpr uint32_t RCC_APB1ENR_TIM4EN =  (1 << 2);
constexpr uint32_t RCC_APB1ENR_TIM3EN =  (1 << 1);
constexpr uint32_t RCC_APB1ENR_TIM2EN =  (1 << 0);



// Bits 31-19 reserved
constexpr uint32_t RCC_APB2ENR_TIM11EN = (1 << 18);
constexpr uint32_t RCC_APB2ENR_TIM10EN = (1 << 17);
constexpr uint32_t RCC_APB2ENR_TIM9EN = (1 << 16);
// Bit 15 reserved
constexpr uint32_t RCC_APB2ENR_SYSCFGEN = (1 << 14);
// Bit 13 reserved
constexpr uint32_t RCC_APB2ENR_SPI1EN = (1 << 12);
constexpr uint32_t RCC_APB2ENR_SDIOEN = (1 << 11);
constexpr uint32_t RCC_APB2ENR_ADC3EN = (1 << 10);
constexpr uint32_t RCC_APB2ENR_ADC2EN = (1 << 10);
constexpr uint32_t RCC_APB2ENR_ADC1EN = (1 << 10);
// Bits 7-6 reserved
constexpr uint32_t RCC_APB2ENR_USART6EN = (1 << 5);
constexpr uint32_t RCC_APB2ENR_USART1EN = (1 << 4);
// Bits 3-2 reserved
constexpr uint32_t RCC_APB2ENR_TIM8EN = (1 << 1);
constexpr uint32_t RCC_APB2ENR_TIM1EN = (1 << 0);






// volatile RCC_TypeDef* const RCC = reinterpret_cast<volatile RCC_TypeDef*>(RCC_BASE);
const uint32_t RCC_BASE =  0x40023800;

// volatile RCC_TypeDef* const RCC = reinterpret_cast<

// #define RCC ((volatile RCC_TypeDef*)RCC_BASE)
auto* const RCC = reinterpret_cast<volatile RCC_TypeDef*>(RCC_BASE);
// stm32::hw::RCC  ???




// TODO: Should this stuff be moved to a dedicated "gpio.h" under
// an stm32f407 directory?
// There can still be a header that includes them all.

// TODO: Things like "typedef struct" can just be "struct" with C++
typedef struct
{
    uint32_t MODER;     /// Pin mode selection
    uint32_t OTYPER;
    uint32_t OSPEEDR;
    uint32_t PUPDR;     /// Enable or disable internal pull ups on GPIO pins
    uint32_t IDR;       /// Pin input register
    uint32_t ODR;       /// Pin output register
    uint32_t BSRR;      /// Atomic set/reset of pin outputs
    uint32_t LCKR;      /// Pin configuration locking
    uint32_t AFRL;      /// Alternate function selection for pins 0-7
    uint32_t AFRH;      /// Alternate function selection for pins 8-15
} GPIO_TypeDef;


// Which makes more sense?
    // GPIOA->MODER |= (GPIO_MODER_OUTPUT << GPIO_MODER_MODE0);
    // GPIOA->MODER |= (GPIO_MODER_OUTPUT << GPIO_MODER_MODE0_Pos);

// #define GPIO_MODER_MODE0_Pos  0
// #define GPIO_MODER_MODE0  (1 << GPIO_MODER_MODE0_Pos)

// Stuff like this didn't exist in the other header:
const uint32_t GPIO_MODER_INPUT =  0x00;
const uint32_t GPIO_MODER_OUTPUT =  0x01;
const uint32_t GPIO_MODER_ALTERNATE =  0x02;
const uint32_t GPIO_MODER_ANALOG =  0x03;



const uint32_t GPIO_BSRR_BS0 =  (1 << 0);
const uint32_t GPIO_BSRR_BS1 =  (1 << 1);
const uint32_t GPIO_BSRR_BS2 =  (1 << 2);
const uint32_t GPIO_BSRR_BS3 =  (1 << 3);
const uint32_t GPIO_BSRR_BS4 =  (1 << 4);
const uint32_t GPIO_BSRR_BS5 =  (1 << 5);
const uint32_t GPIO_BSRR_BS6 =  (1 << 6);
const uint32_t GPIO_BSRR_BS7 =  (1 << 7);
const uint32_t GPIO_BSRR_BS8 =  (1 << 8);
const uint32_t GPIO_BSRR_BS9 =  (1 << 9);
const uint32_t GPIO_BSRR_BS10 =  (1 << 10);
const uint32_t GPIO_BSRR_BS11 =  (1 << 11);
const uint32_t GPIO_BSRR_BS12 =  (1 << 12);
const uint32_t GPIO_BSRR_BS13 =  (1 << 13);
const uint32_t GPIO_BSRR_BS14 =  (1 << 14);
const uint32_t GPIO_BSRR_BS15 =  (1 << 15);

const uint32_t GPIO_BSRR_BR0 =  (1 << 16);
const uint32_t GPIO_BSRR_BR1 =  (1 << 17);
const uint32_t GPIO_BSRR_BR2 =  (1 << 18);
const uint32_t GPIO_BSRR_BR3 =  (1 << 19);
const uint32_t GPIO_BSRR_BR4 =  (1 << 20);
const uint32_t GPIO_BSRR_BR5 =  (1 << 21);
const uint32_t GPIO_BSRR_BR6 =  (1 << 22);
const uint32_t GPIO_BSRR_BR7 =  (1 << 23);
const uint32_t GPIO_BSRR_BR8 =  (1 << 24);
const uint32_t GPIO_BSRR_BR9 =  (1 << 25);
const uint32_t GPIO_BSRR_BR10 =  (1 << 26);
const uint32_t GPIO_BSRR_BR11 =  (1 << 27);
const uint32_t GPIO_BSRR_BR12 =  (1 << 28);
const uint32_t GPIO_BSRR_BR13 =  (1 << 29);
const uint32_t GPIO_BSRR_BR14 =  (1 << 30);
const uint32_t GPIO_BSRR_BR15 =  (1 << 31);




// TODO: The other bits are masks for values which can
// be bitwise-OR'ed directly onto the register.
// These are positions which shift the value before they
// can be OR'ed. Either I need to generate e.g. GPIO_AFRLx_AFy
// for 0<=x<=7 and 0<=y<=15 (and for AFRH as well), or I'll need
// to use templates or something to generate them (or be okay
// with shifting a value into a bit slot similar to the way I'm
// doing GPIO MODER values).
//
// I don't think it would be totally unreasonable to generate
// this file using Python. I might even be able to just parse
// the SVD files using Python and generate them that way?
constexpr uint32_t GPIO_AFRL7 = 28;
constexpr uint32_t GPIO_AFRL6 = 24;
constexpr uint32_t GPIO_AFRL5 = 20;
constexpr uint32_t GPIO_AFRL4 = 16;
constexpr uint32_t GPIO_AFRL3 = 12;
constexpr uint32_t GPIO_AFRL2 = 8;
constexpr uint32_t GPIO_AFRL1 = 4;
constexpr uint32_t GPIO_AFRL0 = 0;

// ...
constexpr uint32_t GPIO_AF1 = 1;
constexpr uint32_t GPIO_AF0 = 0;

// Example:
// constexpr uint32_t GPIO_AFRL2_AF7 = (7 << GPIO_AFRL2);




// TODO: Confirm all of this from manual (Table 1)

// I'm not sure it's really worth offsetting by PERIPH_BASE, AHB1PERIPH_BASE, etc.
// since the plain addresses are given in the table.

// #define PERIPH_BASE  0x40000000
// #define AHB1PERIPH_BASE  PERIPH_BASE + 0x00000000
// #define GPIOA_BASE  AHB1PERIPH_BASE + 0x0000


// const uint32_t GPIOA_BASE =  0x40020000;
// const uint32_t GPIOB_BASE =  0x40020400;
// const uint32_t GPIOC_BASE =  0x40020800;
// const uint32_t GPIOD_BASE =  0x40020c00;
// const uint32_t GPIOE_BASE =  0x40021000;
// const uint32_t GPIOF_BASE =  0x40021400;
// const uint32_t GPIOG_BASE =  0x40021800;
// const uint32_t GPIOH_BASE =  0x40021c00;
// const uint32_t GPIOI_BASE =  0x40022000;
// const uint32_t GPIOJ_BASE =  0x40022400;
// const uint32_t GPIOK_BASE =  0x40022800;


// // volatile GPIO_TypeDef* const GPIOA = reinterpret_cast<volatile GPIO_TypeDef*>(GPIOA_BASE);
// #define GPIOA ((volatile GPIO_TypeDef*)GPIOA_BASE)
// #define GPIOB ((volatile GPIO_TypeDef*)GPIOB_BASE)
// #define GPIOC ((volatile GPIO_TypeDef*)GPIOC_BASE)
// #define GPIOD ((volatile GPIO_TypeDef*)GPIOD_BASE)
// #define GPIOE ((volatile GPIO_TypeDef*)GPIOE_BASE)
// #define GPIOF ((volatile GPIO_TypeDef*)GPIOF_BASE)
// #define GPIOG ((volatile GPIO_TypeDef*)GPIOG_BASE)
// #define GPIOH ((volatile GPIO_TypeDef*)GPIOH_BASE)
// #define GPIOI ((volatile GPIO_TypeDef*)GPIOI_BASE)

auto* const GPIOK = reinterpret_cast<volatile GPIO_TypeDef*>(0x40022800);
auto* const GPIOJ = reinterpret_cast<volatile GPIO_TypeDef*>(0x40022400);
auto* const GPIOI = reinterpret_cast<volatile GPIO_TypeDef*>(0x40022000);
auto* const GPIOH = reinterpret_cast<volatile GPIO_TypeDef*>(0x40021c00);
auto* const GPIOG = reinterpret_cast<volatile GPIO_TypeDef*>(0x40021800);
auto* const GPIOF = reinterpret_cast<volatile GPIO_TypeDef*>(0x40021400);
auto* const GPIOE = reinterpret_cast<volatile GPIO_TypeDef*>(0x40021000);
auto* const GPIOD = reinterpret_cast<volatile GPIO_TypeDef*>(0x40020c00);
auto* const GPIOC = reinterpret_cast<volatile GPIO_TypeDef*>(0x40020800);
auto* const GPIOB = reinterpret_cast<volatile GPIO_TypeDef*>(0x40020400);
auto* const GPIOA = reinterpret_cast<volatile GPIO_TypeDef*>(0x40020000);


template<uint32_t GPIO_BASE>
class Gpio
{
    // Might have to get creative since I don't want
    // static_assert(is_same<GPIO_TypeDef*, GPIO_T>::value, "blah");


public:

    // static volatile * const GPIO_TypeDef = reinterpret_cast<

    // static const auto raw_address = GPIO_BASE;
    // static const auto* raw = reinterpret_cast<volatile GPIO_TypeDef*>(GPIO_BASE);

    static volatile GPIO_TypeDef* raw()
    {
        return reinterpret_cast<volatile GPIO_TypeDef*>(GPIO_BASE);
    }

    static bool checkInput(uint32_t index)
    {
        return (raw()->IDR & (1 << index)) != 0;
    }


};


constexpr uint32_t GPIOD_BASE = 0x40020c00;
constexpr uint32_t GPIOA_BASE = 0x40020000;

typedef Gpio<GPIOA_BASE> GpioA;


namespace gpio
{

    template<uint32_t GPIO_BASE>
    volatile GPIO_TypeDef* raw();

}




// USART is probably the next one to implement in order to
// get debugging info out of the board

// TODO: Confirm which are UARTs and which are USARTs,
// and which even really exist on this device.
// What happened to USART1 and USART6? Did they ever exist?
// #define UART8_BASE  0x40007c00
// #define UART7_BASE  0x40007800
// #define UART5_BASE  0x40005000
// #define UART4_BASE  0x40004c00
// #define USART3_BASE  0x40004800
// #define USART2_BASE  0x40004400







// Timers
typedef struct
{
    uint32_t CR1;
    uint32_t CR2;
    uint32_t SMCR;
    uint32_t DIER;
    uint32_t SR;
    uint32_t EGR;
    uint32_t CCMR1;
    uint32_t CCMR2;
    uint32_t CCER;
    uint32_t CNT;
    uint32_t PSC;
    uint32_t ARR;
    uint32_t _reserved0[1];
    uint32_t CCR1;
    uint32_t CCR2;
    uint32_t CCR3;
    uint32_t CCR4;
    uint32_t _reserved1[1];
    uint32_t DCR;
    uint32_t DMAR;
    uint32_t OR;
} TIM_TypeDef;


const uint32_t TIM_CR1_CEN =  (1 << 0);

const uint32_t TIM_SR_CC3IF =  (1 << 3);
const uint32_t TIM_SR_CC2IF =  (1 << 2);
const uint32_t TIM_SR_CC1IF =  (1 << 1);
const uint32_t TIM_SR_UIF =  (1 << 0);


// TODO: Find a better C++-way to do these flags?
// Maybe with namespaces or something

const uint32_t TIM_DIER_CC3IE =   (1 << 3);
const uint32_t TIM_DIER_CC2IE =   (1 << 2);
const uint32_t TIM_DIER_CC1IE =   (1 << 1);
const uint32_t TIM_DIER_UIE =  (1 << 0);



// #define TIM8_BASE  0x40010400
// #define TIM1_BASE  0x40010000

// #define TIM14_BASE  0x40002000
// #define TIM13_BASE  0x40001c00
// #define TIM12_BASE  0x40001800
// #define TIM7_BASE  0x40001400
// #define TIM6_BASE  0x40001000

// #define TIM5_BASE  0x40000c00
// #define TIM4_BASE  0x40000800
// #define TIM3_BASE  0x40000400
// #define TIM2_BASE  0x40000000

// #define TIM2 ((volatile TIM_TypeDef*)TIM2_BASE)
// #define TIM3 ((volatile TIM_TypeDef*)TIM3_BASE)
// #define TIM4 ((volatile TIM_TypeDef*)TIM4_BASE)
// #define TIM5 ((volatile TIM_TypeDef*)TIM5_BASE)

auto* const TIM5 = reinterpret_cast<volatile TIM_TypeDef*>(0x40000c00);
auto* const TIM4 = reinterpret_cast<volatile TIM_TypeDef*>(0x40000800);
auto* const TIM3 = reinterpret_cast<volatile TIM_TypeDef*>(0x40000400);
auto* const TIM2 = reinterpret_cast<volatile TIM_TypeDef*>(0x40000000);







